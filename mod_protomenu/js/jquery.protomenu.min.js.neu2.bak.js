
/**
 * @package        HEAD. Protomenü 2
 * @version        3.0.5
 * 
 * @author         Carsten Ruppert <webmaster@headmarketing.de>
 * @link           https://www.headmarketing.de
 * @copyright      Copyright © 2018 HEAD. MARKETING GmbH All Rights Reserved
 * @license        http://www.gnu.org/licenses/gpl-2.0.html GNU/GPL
 */
/**
	Protomenu 2.1.0
	Carsten Ruppert - 2018-06-12

	2.1.0 - 2018-06-12
	- Fix für MouseOver

	2.0.1 - 2018-03-01
	- Fix für MouseOver: Untermenus bleiben geschlossen, obwohl Mauszeiger auf einem Elterneintrag zeigt.

	2.0.0 - 2018-02-23
	- Plugins können nun auch dynamisch pro Instant geladen werden, nicht mehr nur für alle Instanzen
	- Fix von statischen CSS-Klassennamen im Code
	- Doppeltes auslösen von Event afterStateChanged korrigiert

	0.12.0 - 2018-02-22
	- Fix der Plugin-Logik. Es wurde immer ein und die gleiche Instanz eines Plugin-Objekts (Backdrop) benutzt, egal wieviele Instanzen von Protomenu existierten.
	- Fix von Backdrop-Plugin

	0.11.0 – 2017-11-29
	- Unterscheidung Touch und Mouseover, wenn Option „Mouseover” eingeschaltet ist.
	- etc.

	0.10.0 – 2017-11-06
	- Entkernt!
	- Abhängigkeit von $.prepareTransition entfernt
	- Abhängigkeit von $.touchSwipe entfernt

*/
'use strict';
(function($) {

	$.Protomenu = function( options, node )
	{
		this.$node = $(node); // <nav/div class="ptmenu">
		this.$node.data('protomenu', this);
		this._init( options );
	};

	$.Protomenu.defaults = {
		classNames : {
			open 	: 'open',
			in 		: 'in'
		},
		classRtl 		: 'rtl',
		classBtt 		: 'btt',
		autoalign 		: true,
		seperateswitch 	: false, 	// Hier auf true setzen, wenn Umschalter und Anke getrennt werden sollen.
		mouseover 		: false, 	// Öffnen von Untermenüs bei Mouseover
		clickAnywhere 	: false,	// Irgendwo klicken um alle Menüs zu schließen? (Außer in dem Menü selbst, oder einem Modul in einem Menü)
		plugins 		: []
	};

	$.Protomenu.Plugins = [];

	$.Protomenu.prototype = {
		
		_init : function( options )
		{
			this.opt 	= $.extend({}, $.Protomenu.defaults, options);
			this.menu  	= this.$node.find('.nav-first');

			//if(this.opt.mouseover)
			//{
				this.trigger = $('[data-ptm-item]', this.$node);
				console.log(this.trigger);
			//}
			//else
			//{
			//	this.trigger = $('[data-ptm-item]:has([data-ptm-child])', this.menu).not(':has( > [data-ptm-static-child])');
			//}

			this.pairSubmenuWithTrigger();
		//	this.setupTriggers();
		//	this.setupEvents();
		},


		/*
			Auslösereignis an Auslöser für Untermenüs „el” binden (Anker oder separater „Umschalter”).

			el – jQuery - Ein <a class="nav-item"> oder ein <xyz class="item-switch"> unterhalb von <a ...
		*/
		attachTriggerEvent : function(el)
		{
			let self = this;
			if(this.opt.mouseover)
			{
				el.on('mouseover.protomenu', function(ev) 
				{
					let item = $(this);
					if(item.data('ptmenu'))
					{
						ev.stopPropagation();
					}
					self.toggleSubmenu(item, true);
				});

				el.on('touchstart.protomenu', function(ev) 
				{
					let item = $(this);
					if(item.data('ptmenu') && $(ev.target).parents('[data-ptm-item]').get(0) === this)
					{
						ev.preventDefault();
						ev.stopPropagation();
					}
					self.toggleSubmenu(item);
				});
			}
			else {
				el.on('click.protomenu', function(ev)
				{
					let item = $(this);

					if(item.data('ptmenu'))
					{
						ev.preventDefault();
						ev.stopPropagation();
					}
					self.toggleSubmenu(item);
				});
			}
		},

		/*
			Sonstige Events einrichten.
		*/
		setupEvents : function() {
			let self = this;

			//if( this.opt.clickAnywhere )
			//{
				$(document).on('click', function(ev)
				{ // Klick irgendwo zu schließen
					self.closeRootLevel();
				});
			//}
			// -- Bubbling stoppen:
			this.$node.find('.nav-module, .nav-item').on('click.protomenu', function(ev)
			{ // Verhindern, dass ein klick auf den Content eines Moduls im Menü den Click-Event am Body auslöst.
				ev.stopPropagation();
			});
		},


		pairSubmenuWithTrigger : function()
		{
			for(let i = 0; i < this.trigger.length; i++)
			{
				let item  	= this.trigger.eq(i),
					id  	= item.data('ptm-item'),
					target 	= $('[data-ptm-child="' + id + '"]', item);

				if(target)
				{
					item.data('ptm-target', target);

					// Ein Submenu kann mehrere Trigger haben, z.B. im Navigationspfad im Submenu-Header.
					if(target.data('ptm-trigger')) 
					{
						target.data('ptm-trigger').push(item);
					}
					else
					{
						target.data('ptm-trigger', [item]);
					}

					console.log(target.data('ptm-trigger'));//debug
				}
			}
		},


		/*
			Auslöser einrichten
		*/
		setupTriggers : function()
		{	
			/*
			let submenus = this.$menu.find('[data-ptm-child]');
			
			for(let i = 0, ilen = submenus.length; i < ilen; i++)
			{
				let sub = submenus.eq(i),
					triggers;

				if(!this.opt.mouseover) 
				{
					triggers = this.$menu.find('[data-ptm-trigger="' + sub.data('ptm-child') + '"]');
				}
				else 
				{
					triggers = this.$menu.find('[data-ptm-item="' + sub.data('ptm-child') + '"]');
				}
					

				for(let x = 0, xlen = triggers.length; x < xlen; x++)
				{
					let trigger = triggers.eq(x),
						d  		= {submenu : sub},
						sep 	= trigger.find('[data-ptm-switcher]');

					trigger = sep.length && this.opt.seperateswitch ? sep : trigger;
					trigger.data('ptmenu', d);
				}

				let d = {triggers : triggers};
				sub.data('ptmenu', d);
			}

			let triggers;
			
			if(!this.opt.mouseover) 
			{
				triggers = this.$menu.find('[data-ptm-trigger]');
			}
			else 
			{
				triggers = this.$menu.find('[data-ptm-item]').not('[data-ptm-item].static');
			}

			for(let i = 0, ilen = triggers.length; i < ilen; i++)
			{
				let trigger  = triggers.eq(i),
					switcher = trigger.find('[data-ptm-switcher]');
				
				if(switcher.length && this.opt.seperateswitch) {
					trigger = switcher;
				} 
				
				this.attachTriggerEvent(trigger);
			}
			*/
		},

		/*
			Deaktiviert alle „Auslöser” eines „Untermenüs”.
		*/
		disableTriggers : function(sub)
		{
			sub.data('ptmenu').triggers.removeClass(this.opt.classNames.open);

			let descestors = sub.find('[data-ptm-child]');
			for(let i = 0, len = descestors.length; i < len; i++)
			{
				let d = descestors.eq(i).data('ptmenu');
				
				if(d) 
				{
					d.triggers.removeClass(this.opt.classNames.open); // Auslöser aller Nachkommen deaktivieren
				}
			}
		},



		getVps : function() {
			let w = window,
				e = document.documentElement,
				b = document.getElementsByTagName('body')[0],
				x = w.innerWidth || e.clientWidth || b.clientWidth,
				y = w.innerHeight|| e.clientHeight|| b.clientHeight;

			return {w : x, h : y};
		},

		isInViewport: function (sub, el) {
			var vp = this.getVps(),
				sp = sub.scrollTop();

			if (vp.h + sp >= el.offset().top && el.offset().top + el.height() > sp) {
				return true;
			}

			return false;
		},

		/*
		setSubmenuScrollPosition : function (sub) 
		{
			//let active = sub.find('[data-ptm-item].active');
			let active  = $('[data-ptm-item].active', sub),
				gap 	= $('.nav-child-header', sub);

			gap = gap.length ? gap.outerHeight() : 0;

			if(active.length && !this.isInViewport(sub, active.eq(active.length -1)))
			{
				this.$wrapper.scrollTop(Math.ceil(active.eq(active.length -1).position().top) - gap);
			}
			else
			{
				this.$wrapper.scrollTop(0)
			}
		},
		*/


		/*
			Macht ein „Untermenü” auf
		*/
		showSub : function(sub)
		{
			let d = sub.data('ptmenu');

			if(d.timeout && this.opt.mouseover) window.clearTimeout(d.timeout); // Sofern für dieses „sub” ein Timeout in closeSub gesetzt wurde, müssen wir diesen hier löschen.

			this.closeEqualLevel(sub);

			sub.addClass(this.opt.classNames.in);


			//this.setSubmenuScrollPosition(sub);

			if(this.getVps().w - (sub.offset().left + sub.outerWidth()) < 0) {
				sub.addClass(this.opt.classRtl);
			}
			if(this.getVps().h - (sub.offset().top + sub.outerHeight()) < 0) {
			//	sub.addClass(this.opt.classBtl);
			}

			sub.addClass(this.opt.classNames.open);
			d.triggers.addClass(this.opt.classNames.open);

			this.$node.triggerHandler('afterStateChanged', {opened : sub});
		},
		/*
			Schließe alle „Nachkommen” eines „Untermenüs”.
		*/
		disableDescestors : function(sub)
		{
			let descestors = sub.find('[data-ptm-child]');
			descestors.removeClass('open');
		},

		/*
			Macht ein „Untermenü”, und dessen „Nachkommen”, zu.
		*/
		hideSub : function(sub)
		{
			sub.removeClass('open');

			this.disableDescestors(sub);
			this.disableTriggers(sub);

			this.$node.triggerHandler('afterStateChanged', {closed : sub});
		},
		/*
			Sucht und schließt offene Elemente im Root-Level (und alle darunter). Wird bei Mouseover true benutzt.
		*/
		closeRootLevel : function()
		{
			// let sub = this.$menu.find('.nav-child.nav-level-2.' + this.opt.classNames.open);
			let sub = this.$menu.find('.' + this.opt.classNames.open + '[data-ptm-child][data-ptm-level="2"]');

			if(sub.length) this.hideSub(sub);
		},

		/*
			Mach Alles auf der gleichen Ebene zu.
		*/
		closeEqualLevel : function(el)
		{
			//let subs = el.parent().parent().find('.' + this.opt.classNames.open + '[data-ptm-child]').not(el);

			let subs = el.parent().parent().find('.' + this.opt.classNames.open + '[data-ptm-child]').not(el);

			for(let i = 0, len = subs.length; i < len; i++ )
			{
				this.hideSub(subs.eq(i));
			}
		},

		/*
			Ist noch irgenein sub offen?
		*/
		isExpanded : function(first)
		{
			let something;
			if(first) // Nur im first-level suchen
			{
				something = this.$menu.find('.' + this.opt.classNames.open + '[data-ptm-child][data-ptm-level="2"]');
			}
			else
			{
				something = this.$menu.find('.' + this.opt.classNames.open + '[data-ptm-child]');
			}

			if(something.length)
				return true;

			return false;
		},

		toggleSubmenu : function(trigger, mouseover)
		{	
			if(!trigger.data('ptmenu')) // Dieser „Trigger” hat kein Untermenü, wenn "this.opt.mouseover" an ist, könnte aber ein „Untermenü” offen sein, welches ausgeblendet werden muss.
			{
				if(mouseover) this.closeEqualLevel(trigger);
				return;
			}

			let sub 	= trigger.data('ptmenu').submenu,
				isopen 	= sub.hasClass(this.opt.classNames.open);

			if(isopen && !mouseover)
			{
				this.hideSub(sub);
				trigger.blur();
			}
			else if(!isopen) {
				this.showSub(sub);
			}

			if( mouseover && !isopen )
			{
				/**
					Wenn die Eltern-Liste des <li> verlassen wird, machen wir alles innerhalb der Eltern-Liste zu.
					Das wird nötig, wenn Dropdown-Menüs in Megamenüs und in Spalten dargestellt werden */
				let parentList = trigger.parents('[data-ptm-sub]');
				parentList.one('mouseout.protomenu', function(trigger, sub, ev) 
				{
					if(ev.currentTarget === ev.relatedTarget) 
					{
						this.closeEqualLevel($(ev.currentTarget));
					}
				}.bind(this, trigger, sub));

				// -- Wenn <ul data-ptm-root> verlassen wird machen wir Alles zu.
				$(document).off('mousemove.protomenu').on('mousemove.protomenu', function(ev) {
					if(!$(ev.target).closest('[data-ptm-root]').length )
					{
						$(document).off('mousemove.protomenu');
						this.closeRootLevel();
					}
				}.bind(this));
			}
		}
	} // prototype

	$.fn.protomenu = function(options)
	{
		let self = $(this).data('protomenu');

		if( self === undefined )
		{
			self = new $.Protomenu(options, this);
		}
		return self;
	}

})(jQuery);


(function($) {

	//$.Protomenu.Plugins.push('ProtomenuBackdrop');

	$.Protomenu.defaults.backDrop = {
		template : '<div class="ptmenu-backdrop"></div>'
	};

	$.ProtomenuBackdrop = function(parent) {
		this.parent = parent;
		this._init();
	}

	$.ProtomenuBackdrop.prototype = {
		_init : function()
		{
			this.backdrop 	= $(this.parent.opt.backDrop.template);
			this.timer 		= null;

			$('body').prepend(this.backdrop);

			this.parent.$node.on('afterStateChanged', function(ev)
			{
				if(this.parent.isExpanded(true))
				{
					this.backdrop.addClass( $.map(this.parent.opt.classNames, function(n){return n}).join(' ') );
				}
				else
				{
					this.close();
				}
			}.bind(this));
		},

		close : function()
		{
			window.clearTimeout(this.timer);

			var time = 0;
			this.backdrop.css('transition-duration').split(',').forEach(function(dur)
			{
				dur = parseFloat(dur);
				time = dur > time ? dur : time;
			});

			var afterTransition = function()
			{
				if(this.parent.isExpanded()) return;
				this.backdrop.removeClass(this.parent.opt.classNames.in);
			};

			this.timer = window.setTimeout(
				afterTransition.bind(this),
				time * 1000
			);

			this.backdrop.removeClass(this.parent.opt.classNames.open);
		}
	}

})(jQuery);